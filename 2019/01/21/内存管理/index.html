<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS开发,Objective-C," />










<meta name="description" content="内存管理五大内存区域 栈区，堆区，全局区，常量区，代码区 五大内存区域之外还有 自由存储区也称之五大区域之外区">
<meta name="keywords" content="iOS开发,Objective-C">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理">
<meta property="og:url" content="http://lizechuang.github.io/2019/01/21/内存管理/index.html">
<meta property="og:site_name" content="李先生的随笔">
<meta property="og:description" content="内存管理五大内存区域 栈区，堆区，全局区，常量区，代码区 五大内存区域之外还有 自由存储区也称之五大区域之外区">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-02-19T13:05:17.630Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="内存管理">
<meta name="twitter:description" content="内存管理五大内存区域 栈区，堆区，全局区，常量区，代码区 五大内存区域之外还有 自由存储区也称之五大区域之外区">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lizechuang.github.io/2019/01/21/内存管理/"/>





  <title>内存管理 | 李先生的随笔</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李先生的随笔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">如人饮水，冷暖自知</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lizechuang.github.io/2019/01/21/内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李先生的随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">内存管理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-21T22:00:00+08:00">
                2019-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发/" itemprop="url" rel="index">
                    <span itemprop="name">开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="五大内存区域"><a href="#五大内存区域" class="headerlink" title="五大内存区域"></a>五大内存区域</h2><blockquote>
<p>栈区，堆区，全局区，常量区，代码区</p>
<p>五大内存区域之外还有 自由存储区也称之五大区域之外区</p>
</blockquote>
<a id="more"></a>
<h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>创建临时变量时由编译器自动分配，在不需要的时候自动清除的变量的存储区。</p>
<p>里面的变量通常是局部变量、函数参数等。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface TestObject()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation TestObject</span><br><span class="line">- (void)testMethodWithName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">   //方法参数name是一个指针，指向传入的参数指针所指向的对象内存地址。name是在栈中</span><br><span class="line">  //通过打印地址可以看出来，传入参数的对象内存地址与方法参数的对象内存地址是一样的。但是指针地址不一样。</span><br><span class="line">  NSLog(@&quot;name指针地址:%p,name指针指向的对象内存地址:%p&quot;,&amp;name,name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //*person 是指针变量,在栈中, [Person new]是创建的对象,放在堆中。</span><br><span class="line">  //person指针指向了[Person new]所创建的对象。</span><br><span class="line">  //那么[Person new]所创建的对象的引用计数器就被+1了,此时[Person new]对象的retainCount为1</span><br><span class="line">  Person *person = [Person new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>就是那些由 new alloc 创建的对象所分配的内存块，它们的释放系统不会主动去管，由我们的开发者去告诉系统什么时候释放这块内存(一个对象引用计数为0是系统就会回销毁该内存区域对象)。</p>
<p>一般一个 new 就要对应一个 release。在ARC下编译器会自动在合适位置为OC对象添加release操作。会在当前线程Runloop退出或休眠时销毁这些对象，MRC则需程序员手动释放。</p>
<p>堆可以动态地扩展和收缩。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//alloc是为Person对象分配内存,init是初始化Person对象。本质上跟[Person new]一样。</span><br><span class="line">Person *person = [[Person alloc] init];</span><br></pre></td></tr></table></figure>
<h3 id="全局-静态存储区"><a href="#全局-静态存储区" class="headerlink" title="全局/静态存储区"></a>全局/静态存储区</h3><p>全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，</p>
<p>未初始化的全局变量与静态变量在相邻的另一块区域，<br>同时未被初始化的对象存储区可以通过 void* 来访问和操纵，<br>程序结束后由系统自行释放），在 C++ 里面没有这个区分了，<br>他们共同占用同一块内存区。</p>
<h3 id="常量存储区"><a href="#常量存储区" class="headerlink" title="常量存储区"></a>常量存储区</h3><p>这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。一般值都是放在这个地方的。</p>
<h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><p>存放函数的二进制代码。</p>
<h3 id="自由存储区"><a href="#自由存储区" class="headerlink" title="自由存储区"></a>自由存储区</h3><p>就是那些由 malloc 等分配的内存块，他和堆是十分相似的，不过它是用 free 来结束自己的生命的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NSString *string1;//string1 这个NSString 类型的指针,未初始化存在于&lt;全局区&gt;的&lt;BBS区&gt;</span><br><span class="line"></span><br><span class="line">NSString *string2 = @&quot;1234&quot;;//string2 这个NSString类型的指针，已初始化存在与&lt;全局区&gt;的&lt;data数据区&gt;，@“1234”存在与堆区，因为@代表了对象。 </span><br><span class="line"></span><br><span class="line">static NSString *string3;//string3 这个NSString 类型的指针存在于&lt;全局区&gt;的&lt;BBS区&gt;</span><br><span class="line"></span><br><span class="line">static NSString *string4 = @&quot;1234&quot;;//string4 这个NSString类型的指针存在与&lt;全局区&gt;的&lt;data数据区&gt;，@“1234”存在与堆区，因为@代表了对象。stiring2和string4的值地址是一样的</span><br><span class="line"></span><br><span class="line">static const NSString *string5 = @&quot;654321&quot;;//const 修饰后  string5不能修改值。 其他的与string4一样</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">int  a;//a这个int类型的变量 是存在与&lt;栈区&gt;的</span><br><span class="line">a = 10;//10这个值是存在与 &lt;常量区&gt;的</span><br><span class="line"></span><br><span class="line">NSStirng *str；//str这个NSString类型的指针 存在于&lt;栈区&gt;</span><br><span class="line">str = @“1234”；//@“1234”这个@对象存在于 &lt;堆区&gt;</span><br><span class="line"></span><br><span class="line">static NSString *str1;//str1这个NSString类型的指针 存在于&lt;全局区&gt;的&lt;BBS区&gt;</span><br><span class="line">static NSString *str2 = @&quot;4321&apos;;//str2这个NSString类型的指针 存在于&lt;全局区&gt;的&lt;data区&gt;</span><br><span class="line"></span><br><span class="line">NSString *str3;//str3这个NSString类型的指针 存在于&lt;栈区&gt;</span><br><span class="line">str3 = [[NSString alloc]initWithString:@&quot;1234&quot;];//[[NSString alloc]initWithString:@&quot;1234&quot;]这个对象 存在于&lt;堆区&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="static静态变量"><a href="#static静态变量" class="headerlink" title="static静态变量"></a>static静态变量</h3><p>静态变量有两种</p>
<ul>
<li><p>全局静态变量</p>
<ul>
<li>优点：不管对象方法还是类方法都可以访问和修改全局静态变量，并且外部类无法调用静态变量，定义后只会指向固定的指针地址，供所有对象使用，节省空间。</li>
<li>缺点：存在的生命周期长，从定义直到程序结束。</li>
<li>建议：从内存优化和程序编译的角度来说，尽量少用全局静态变量，因为存在的声明周期长，一直占用空间。程序运行时会单独加载一次全局静态变量，过多的全局静态变量会造成程序启动慢，当然就目前的手机处理器性能，几十几百个估计也影响不大吧。</li>
</ul>
</li>
<li><p>局部静态变量</p>
<ul>
<li>优点：定义后只会存在一份值，每次调用都是使用的同一个对象内存地址的值，并没有重新创建，节省空间，只能在该局部代码块中使用。</li>
<li>缺点：存在的生命周期长，从定义直到程序结束，只能在该局部代码块中使用。</li>
<li>建议：局部和全局静态变量从本根意义上没有什么区别，只是作用域不同而已。如果值仅一个类中的对象和类方法使用并且值可变，可以定义全局静态变量，如果是多个类使用并可变，建议值定义在model作为成员变量使用。如果是不可变值，建议使用宏定义</li>
</ul>
</li>
</ul>
<blockquote>
<p>static NSString *name;</p>
</blockquote>
<h3 id="extern全局变量"><a href="#extern全局变量" class="headerlink" title="extern全局变量"></a>extern全局变量</h3><p>全局变量有两种</p>
<ul>
<li><p>对内的全局变量：没有用extern在.h中修饰的变量，仅定义在.m中让该变量只能在该类使用</p>
<ul>
<li>优点：不管对象方法还是类方法都可以访问和修改全局静态变量，并且外部类无法调用静态变量，定义后只会存一份值，供所有对象使用，节省空间。跟全局静态变量一样，只是少了static修饰少了static特性</li>
<li>缺点：存在的生命周期长，从定义直到程序结束</li>
<li>建议：建议：跟全局静态变量都一样了，还需要用对内的全局变量吗？不用extern修饰就少了extern的特性，还不如用全局静态变量，至少能明确的知道static是对内使用的</li>
</ul>
</li>
<li><p>外部全局变量：除了该类，其他文件也可以访问该变量</p>
<ul>
<li>优点：定除了该类，其他文件也可以访问该变量</li>
<li>缺点：存在的生命周期长，从定义直到程序结束。并且外部可以修改其值，出现错误不容易定位</li>
<li>建议：使用全局变量的原因就在于其对外的特性，但是其使用的方便性没有使用model的属性或宏来得方便。程序启动的时候会单独加载全局变量，同理与全局静态变量，少使用。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.m中要定义</span><br><span class="line">NSString *name;</span><br><span class="line"></span><br><span class="line">.h中同时要定义</span><br><span class="line">extern NSString *name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>全局静态变量与全局变量 其实本质上是没有区别的，只是存在修饰区别，一个static让其只能内部使用，一个extern让其可以外部使用</p>
</blockquote>
<h3 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h3><ul>
<li>不同于变量，常量的值是固定不可变的，一般用于只读值。<ul>
<li>优点：只可以读取值，不能修改。一般用于接口或者文字显示这种固定值。添加extern可以对外全局常量,任意位置都可以访问</li>
<li>缺点：存在的生命周期长，从定义直到程序结束。需要在.h .m中分别定义代码较多</li>
<li>建议：看个人习惯吧，使用宏或者常量只是编译加载方式不一样而已</li>
</ul>
</li>
</ul>
<h2 id="属性标识符"><a href="#属性标识符" class="headerlink" title="属性标识符"></a>属性标识符</h2><h3 id="property、-synthesize、-dynamic"><a href="#property、-synthesize、-dynamic" class="headerlink" title="@property、@synthesize、@dynamic"></a>@property、@synthesize、@dynamic</h3><ul>
<li><p>@synthesize:在对象属性使用@synthesize声明的时候编译器会自动为该属性按照固有规则生成相应的getter setter方法。如果有手动生成getter setter方法也不会报错。</p>
</li>
<li><p>@dynamic:相反与@synthesize，使用@dynamic声明时相当于告诉编译器getter  setter方法由用户自己生成。如果声明为@dynamic而没有手动生成getter setter方法编译的时候不报错，但是在运行时如果使用.语法去调用该属性时会崩溃。之所以在运行时才会发生崩溃是因为OC具有动态绑定特性。只有在运行时才会去确认具体的调用方法。</p>
</li>
<li><p>@property:相对于@dynamic 和 @synthesize ，@property声明的作用区域在@interface内部。 它会告诉编译器自动生成getter setter方法。也允许用户手动生成getter setter中的一个方法，用@property声明的属性不能手动同时写getter setter方法，否则编译器会报错。@property更好的声明属性变量。因为访问方法的命名约定，可以很清晰的看出getter和setter的用处，会传递一些额外信息，后面会跟相应的各种信息例如:@property (nonatomic, strong，onlyread) NSString *name;大多数时候都用的@property声明</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">@interface TestObject()</span><br><span class="line">//因为使用了@property声明，编译器会自动生成相应getter setter方法。</span><br><span class="line">//使用@property不能手动同时生成getter  setter方法，编译器会报错</span><br><span class="line">//nonatomic表示属性是非原子操作，strong表示强引用，</span><br><span class="line">//readonly表示该属性权限为仅读,那么编译器只会生成getter方法，不会生成setter方法</span><br><span class="line">@property (nonatomic, strong,readonly) NSString *name;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSMutableArray *array;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *dic;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation TestObject</span><br><span class="line"></span><br><span class="line">//如果上面的array使用的@property声明，而用户又要手动同时生成getter  setter方法</span><br><span class="line">//可以使用@synthesize 告诉编译器 该属性getter setter方法如果没有手动声明就自动创建，有就不知道生成。</span><br><span class="line">@synthesize array = _array;</span><br><span class="line"></span><br><span class="line">//如果dic用@property声明过了，会自动生成getter  setter方法。但是又不希望它自动生成getter setter方法。</span><br><span class="line">//可以用@dynamic 声明。告诉编译器 该属性的getter  setter方法不自动生成</span><br><span class="line">@dynamic dic = _dic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)setArray:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    _array = array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    if (!_array) &#123;</span><br><span class="line">        _array = [NSMutableArray new];</span><br><span class="line">    &#125;</span><br><span class="line">    return _array;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setArray:(NSMutableDictionary *)dic</span><br><span class="line">&#123;</span><br><span class="line">    _dic = dic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableDictionary *)dic</span><br><span class="line">&#123;</span><br><span class="line">    if (!_dic) &#123;</span><br><span class="line">        _dic = [NSMutableDictionary new];</span><br><span class="line">    &#125;</span><br><span class="line">    return _array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### nonatomic与atomic</span><br><span class="line"></span><br><span class="line">- nonatomic(非原子性):在调用用nonatomic声明的对象属性时是非线程安全性的。最为直观的就是NSMutableArray的使用。当同时在子线程去增删数组元素，在主线程中去遍历数组元素就会出现数组越界或者数组没有遍历完。因为采用的nonatomic，不同操作可以同时执行，而不需要等前面的操作完成后在进行下一步操作。所以称之为非线程安全。非原子性的执行效率更高不会阻塞线程</span><br><span class="line"></span><br><span class="line">- atomic(原子性):相反与非原子性，atomic是具有线程安全性的。他会在getset方法中加入线程操作。每当对用atomic声明的对象属性操作时，会根据操作加入线程的顺序一步一步完成操作，而不是非原子性的同时操作。执行效率较低一般来说很少用atomic。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 两者的不同</span><br><span class="line"></span><br><span class="line">不写的话默认就是atomic。</span><br><span class="line"></span><br><span class="line">- atomic 和 nonatomic 的区别在于，系统自动生成的 getter/setter 方法不一样。如果你自己写 getter/setter，那 atomic/nonatomic/retain/assign/copy 这些关键字只起提示作用，写不写都一样。</span><br><span class="line">- 对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。</span><br><span class="line">- 而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。</span><br><span class="line">- 不过atomic可并不能保证线程安全。如果线程 A 调了 getter，与此同时线程 B 、线程 C 都调了 setter——那最后线程 A get 到的值，3种都有可能：可能是 B、C set 之前原始的值，也可能是 B set 的值，也可能是 C set 的值。同时，最终这个属性的值，可能是 B set 的值，也有可能是 C set 的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 保证数据完整性——这个多线程编程的最大挑战之一——往往还需要借助其他手段。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### strong、weak、retain、assgin、copy、unsafe_unretained</span><br><span class="line"></span><br><span class="line">#### retain:释放旧对象.</span><br><span class="line">提高输入对象的引用计数+1，将输入对象的值赋值于旧对象，只能用户声明OC对象</span><br></pre></td></tr></table></figure>
<p>@property (nonatomic, retain) Room *room;</p>
<ul>
<li><p>(void)setRoom:(Room *)room // room = r<br>{<br>  // 只有房间不同才需用release和retain<br>  if (_room != room) {  </p>
<pre><code>// 将以前的房间释放掉 -1,将旧对象释放
[_room release];

// MRC中需要手动对房间的引用计数器+1
[room retain];

_room = room;
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### strong:强引用,它是ARC特有。</span><br><span class="line"></span><br><span class="line">在MRC时代没有，相当于retain。由于MRC时代是靠引用计数器来管理对象什么时候被销毁所以用retain，而ARC时代管理对象的销毁是有系统自动判断，判断的依据就是该对象是否有强引用对象。如果对象没有被任何地方强引用就会被销毁。所以在ARC时代基本都用的strong来声明代替了retain。只能用于声明OC对象(ARC特有)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### assgin:简单的赋值操作。</span><br><span class="line">不会更改引用计数，用于基本的数据类型声明。</span><br><span class="line"></span><br><span class="line">#### weak:弱引用，表示该属性是一种“非拥有关系”。</span><br><span class="line">为这种属性设置新值时既不会保留新值也不会释放旧值，类似于assgin。 然而在对象被摧毁时，属性也会被清空（nil out）。这样可以有效的防止崩溃(因为OC中给没有对象地址的指针发送消息不会崩溃，而给有内存地址但地址中是空对象的指针发消息会崩溃，野指针)，该声明必须作用于OC对象。对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</span><br><span class="line"></span><br><span class="line">&gt; (ARC特有),strong 和 weak的指针，根本区别在于，strong执行了retain操作，而weak没有。</span><br><span class="line"></span><br><span class="line">##### copy:不同于其他声明，copy会根据声明的属性是否是可变类型而进行不同操作。</span><br><span class="line"></span><br><span class="line">如果对象是一个不可变对象，例如NSArray NSString 等，那么copy等同于retain、strong。</span><br><span class="line"></span><br><span class="line">如果对象是一个可变对象，例如:NSMutableArray,NSMutableString等，它会在内存中重新开辟了一个新的内存空间,用来 存储新的对象,和原来的对象是两个不同的地址,引用计数分别为1. </span><br><span class="line"></span><br><span class="line">所谓的深拷贝浅拷贝，浅拷贝只是copy了对象的内存地址，而深拷贝是重新在内存中开辟新空间，新空间对象值与拷贝对象的值一样。但是是完全不同的2个内存地址。 </span><br><span class="line"></span><br><span class="line">例如copy修饰的类型为 NSString不可变对象时，copy可以保护其封装性，当赋值对象是一个 NSMutableString 类时(NSMutableString是 NSString 的子类，表示一种可修改其值的字符串），此时若是不用copy修饰拷贝字符串，那么赋值该对象之后，赋值对象字符串的值就可能会在其他地方被修改，修改后赋值后对象也会改变，造成值不对。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</span><br><span class="line"></span><br><span class="line">##### unsafe_unretained</span><br><span class="line">和weak 差不多，唯一的区别便是，对象即使被销毁，指针也不会自动置空， 对象被销毁后指针指向的是一个无用的内存地址(野地址)。如果对象销毁后后还使用此指针，程序会抛出 BAD_ACCESS 的异常。 所以一般不使用unsafe_unretained。(ARC特有)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### readOnly、readWrite、getter=、setter=</span><br><span class="line"></span><br><span class="line">readOnly表示属性仅能读不能设置其值。告诉编译器只生成getter方法不生成setter方法。</span><br><span class="line"></span><br><span class="line">readWrite默认值,表示属性可读可写。编译器会自动生成getter setter方法</span><br><span class="line"></span><br><span class="line">getter=指定属性gettter方法的方法名</span><br><span class="line"></span><br><span class="line">setter=指定属性setter方法的方法名</span><br><span class="line"></span><br><span class="line">### __unsafe_unretained、__weak、__strong</span><br><span class="line"></span><br><span class="line">__unsafe_unretained</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NSMutableArray __unsafe_unretained *array = [[NSMutableArray alloc]init];<br>[array addObject:@”123”];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用__unsafe_unretained修饰符的变量与使用__weak修饰符的变量一样，因为自己生成并持有的对象不能继续为自己持有，所以生成的对象会立即被释放。也就是说在执行完init方法以后，对象指针所指向的内存就已经释放掉了，但因为用的__unsafe_unretained修饰指针并没不像__weak的指针那样，将指针自动置为nil，它依然指向原来的地址，可是这块地址的内存已经被系统回收了，再访问就是非法的，也就是野指针，再执行后面的addObject方法自然会出错了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__weak</span><br><span class="line"></span><br><span class="line">主要用于解决循环引用，用__weak修饰的变量 当对象释放后，指针自动设置为nil，当后面继续使用该指针变量的时候不会造成crash，更不会造成强引用使该释放的对象无法释放，造成内存泄露。</span><br><span class="line"></span><br><span class="line">&gt; __weak typeof(self) weakSelf = self;</span><br><span class="line"></span><br><span class="line">__strong </span><br><span class="line"></span><br><span class="line">相反与__weak,主要用于当使用某个对象是，希望它没有提前被释放。强引用该对象使其无法释放。例如在block内部，希望block调用时该对象不会被提前释放造成错误。可以使用强引用。</span><br></pre></td></tr></table></figure></p>
<p>TestAlertView *alertView = [TestAlertView new];<br>alertView = ^()<br>{<br>  //当block内部需要使用本身这个局部对象时，需要用强引用方式，让alertView在传递完block后不会被释放依然可以执行setTitle操作<br>   __strong typeof(alertView) strongAlertView = alertView;<br>  [strongAlertView setTitle:@”1234”];</p>
<p>}<br>[alertView show];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## MRC手动内存管理</span><br><span class="line">引用计数器:在MRC时代，系统判定一个对象是否销毁是根据这个对象的引用计数器来判断的。</span><br><span class="line"></span><br><span class="line">1. 每个对象被创建时引用计数都为1</span><br><span class="line">2. 每当对象被其他指针引用时，需要手动使用[obj retain];让该对象引用计数+1。</span><br><span class="line">3. 当指针变量不在使用这个对象的时候，需要手动释放release这个对象。 让其的引用计数-1.</span><br><span class="line">4. 当一个对象的引用计数为0的时候，系统就会销毁这个对象。</span><br></pre></td></tr></table></figure></p>
<p>NSMutableArray *array = [NSMutableArray array];//[NSMutableArray array]创建后引用计数器为1<br>    NSLog(@”array的对象地址:%p,array的retainCount:%zd”,array,[array retainCount]);<br>    [array release];//调用release后[NSMutableArray array]创建的对象引用计数-1.</p>
<pre><code> //当程序执行到[array addObject:@&quot;1234&quot;];这里是就会崩溃。因为此时array指针指向的内存地址中没有任何对象，该指针是一个野指针。
 //因为release后[NSMutableArray array]创建的对象引用计数变为了0.系统就会销毁这个内存地址的对象。
[array addObject:@&quot;1234&quot;];
NSLog(@&quot;array的对象地址:%p,array的retainCount:%zd&quot;,array,[array retainCount]);
NSLog(@&quot;%@&quot;,array);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在MRC模式下必须遵循谁创建，谁释放，谁引用，谁管理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ARC自动内存管理</span><br><span class="line"></span><br><span class="line">&gt; WWDC2011和iOS5所引入自动管理机制——自动引用计数（ARC），它不是垃圾回收机制而是编译器的一种特性。</span><br><span class="line"></span><br><span class="line">ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。</span><br><span class="line">在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；</span><br><span class="line">ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略</span><br><span class="line"></span><br><span class="line">1. ARC 会自动执行 retain 、release、autorelease等操作，在ARC下不能主动调用这些内存管理方法。</span><br><span class="line">2. ARC在调用这些方法时，并不通过objective-c的消息转发机制，而是直接调用其底层C语言版本API，这样做性能更好，因为保留及释放操作需要频繁的执行，直接调用其底层的函数能节省很多CPU周期，如ARC会调用与retain等价的底层函数objc_retain.</span><br><span class="line">3. 在使用ARC时必须遵循方法命名规则，alloc，new，copy，mutablecopy。ARC通过命名约定将内存管理标准化。</span><br><span class="line">4. ARC管理对象生命期的办法是：在合适的地方，插入“保留”及“释放”操作。在方法中创建的对象，在方法中自动插入release；类中的对象，在dealloc方法中释放。</span><br><span class="line">5. ARC下，变量的内存管理语义可以通过修饰符指明.</span><br><span class="line">6. ARC只负责管理objective-c 对象的内存，CoreFoundation 对象不归ARC管理。</span><br><span class="line"></span><br><span class="line">## autoreleasepool自动释放池</span><br><span class="line"></span><br><span class="line">&gt; 自动释放池始于MRC时代，主要是用于 自动 对 释放池内 对象 进行引用计数-1的操作，即自动执行release方法。</span><br><span class="line"></span><br><span class="line">在MRC中使用autoreleasepool必须在代码块内部手动为对象调用autorelease把对象加入到的自动释放池，系统会自动在代码块结束后，对加入自动释放池中的对象发送一个release消息。无需手动调用release。</span><br><span class="line"></span><br><span class="line">在ARC中对@autoreleasepool的使用相比MRC不太多。主要用于一些大内存消耗对象的重复创建时，保证内存处于比较优越的状态。常用于创建对象较多的for循环中。在ARC下不要手动的为@autoreleasepool代码块内部对象添加autorelease，ARC下自动的把@autoreleasepool代码块中创建的对象加入了自动释放池中。</span><br><span class="line"></span><br><span class="line">### autorelease对象释放的时机</span><br><span class="line">#### 系统自行创建的@autoreleasepool释放时机</span><br><span class="line"></span><br><span class="line">线程与Runloop是一对一关系，主线程中会自动创建Runloop，而子线程需要自行调用Runloop来让子线程自动创建Runloop。当@autoreleasepool加入到某个线程时，该线程的Runloop会借用autoreleasepool释放对象。</span><br><span class="line"></span><br><span class="line">![image](https://github.com/lizechuang/photoURL/blob/master/photo/runloop.jpeg?raw=true)</span><br><span class="line"></span><br><span class="line">1. 图中第1步 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前</span><br><span class="line">2. 图中第6步 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</span><br><span class="line">3. 图中第10 Observer 监视事件是exit(即讲退出runloop)，其回调内会调用 _objc_autoreleasePoolpop() 释放自动释放池。</span><br><span class="line"></span><br><span class="line">从上面就能看出，Runloop中系统自动创建的@autoreleasepool是在准备进入休眠状态才被销毁的。所以在ARC下，在线程中的临时对象是在当前线程的Runloop进入休眠或者退出loop或者退出线程时被执行release的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 自己创建的@autoreleasepool</span><br></pre></td></tr></table></figure>
<p>@autoreleasepool<br>{//这个{开始创建的自动释放池，这里开始内部的对象自动加入autorelease</p>
<p>}<br><code>`</code></p>
<p>从上面就能看出，自行创建的@autoreleasepool，是在}后被释放的，而其中的autorelease对象，也是在这个时候自动执行的release操作。</p>
<p>从系统创建, 自己创建两点可以看出，虽然autorelease对象释放的时机并不都是在代码块结束后就释放。但是他们有一个共同特性，那就是必定是在@autoreleasepool被销毁时，释放的。 所以要清楚autorelease对象什么时候被释放，只需要搞清楚@autoreleasepool什么时候被销毁即可</p>
<p>主线程中既有系统创建的@autoreleasepool也有开发者自行创建的@autoreleasepool。那么他的释放顺序是怎样的呢？</p>
<p>因为@autoreleasepool是以栈的形式存储的，按照先进后出的规则释放栈中每个@autoreleasepool。主线程的@autoreleasepool是在Runloop一开始就创建了所以，它必然是栈最里面的，而自行创建的@autoreleasepool是在Runloop运行中创建的，所以在栈上面一点。按照栈的规则，@autoreleasepool是先释放自行创建的@autoreleasepool，在释放系统创建的。</p>
<h2 id="NSString的内存存储方式"><a href="#NSString的内存存储方式" class="headerlink" title="NSString的内存存储方式"></a>NSString的内存存储方式</h2><p>NSString的创建方式</p>
<blockquote>
<p>@””,  stringWithFormat, initWithString, initWithFormat四种方式</p>
</blockquote>
<p>直接上概念</p>
<p>由@””,initWithString和stringWithString创建的NSString对象，不管字符串的内容和长度怎么变化，该字符串对象始终是存储在常量区的，引用计数为-1；从用%lu打印来看initWithString和stringWithString创建的字符串retainCount是无符号长整型的最大值。所以可以说他们没有引用计数这个概念。</p>
<p>而由initWithFormat和stringWithFormat创建的对象，如果字符串内容是非汉字的，那么当字符串长度小于10个时，该字符串存储区域在五大区域之外，且随着字符串长度的变化，存储地址会有很大变化。当字符串长度超过10个以后，该字符串在堆中，与正常的OC对象一样。这里为什么要说非汉字呢，因为如果字符串内容是汉字，不管字符串的内容和长度怎么变化，该字符串都是在堆中，与正常OC对象一样。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS开发/" rel="tag"># iOS开发</a>
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/20/KVO详解/" rel="next" title="KVO详解">
                <i class="fa fa-chevron-left"></i> KVO详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lee</p>
              <p class="site-description motion-element" itemprop="description">ios开发</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-number">1.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#五大内存区域"><span class="nav-number">1.1.</span> <span class="nav-text">五大内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#栈区"><span class="nav-number">1.1.1.</span> <span class="nav-text">栈区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆区"><span class="nav-number">1.1.2.</span> <span class="nav-text">堆区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局-静态存储区"><span class="nav-number">1.1.3.</span> <span class="nav-text">全局/静态存储区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量存储区"><span class="nav-number">1.1.4.</span> <span class="nav-text">常量存储区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码区"><span class="nav-number">1.1.5.</span> <span class="nav-text">代码区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自由存储区"><span class="nav-number">1.1.6.</span> <span class="nav-text">自由存储区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static静态变量"><span class="nav-number">1.1.7.</span> <span class="nav-text">static静态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern全局变量"><span class="nav-number">1.1.8.</span> <span class="nav-text">extern全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const常量"><span class="nav-number">1.1.9.</span> <span class="nav-text">const常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性标识符"><span class="nav-number">1.2.</span> <span class="nav-text">属性标识符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#property、-synthesize、-dynamic"><span class="nav-number">1.2.1.</span> <span class="nav-text">@property、@synthesize、@dynamic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSString的内存存储方式"><span class="nav-number">1.3.</span> <span class="nav-text">NSString的内存存储方式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
