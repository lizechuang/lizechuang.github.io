<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS开发,Objective-C," />










<meta name="description" content="Effective Objective-C使用消息结构的语言，其运行时所应执行的代码由运行环境来决定； 使用函数调用的语言，则由编译器决定； 对象所占内存总是分配在“堆空间”中，而绝不会分配在“栈”上。 堆空间存放对象，栈帧存放指向对象的指针. 在类的头文件中尽量少引入其他头文件 多使用字面量语法，少用与之等量的方法 多用类型常量，少用#define预处理指令 12#define ANIMATIO">
<meta name="keywords" content="iOS开发,Objective-C">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Objective-C">
<meta property="og:url" content="http://lizechuang.github.io/2018/11/17/Effective Objective-C/index.html">
<meta property="og:site_name" content="李先生的随笔">
<meta property="og:description" content="Effective Objective-C使用消息结构的语言，其运行时所应执行的代码由运行环境来决定； 使用函数调用的语言，则由编译器决定； 对象所占内存总是分配在“堆空间”中，而绝不会分配在“栈”上。 堆空间存放对象，栈帧存放指向对象的指针. 在类的头文件中尽量少引入其他头文件 多使用字面量语法，少用与之等量的方法 多用类型常量，少用#define预处理指令 12#define ANIMATIO">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/lizechuang/photoURL/blob/master/photo/%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png?raw=true">
<meta property="og:updated_time" content="2019-01-16T11:03:09.046Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective Objective-C">
<meta name="twitter:description" content="Effective Objective-C使用消息结构的语言，其运行时所应执行的代码由运行环境来决定； 使用函数调用的语言，则由编译器决定； 对象所占内存总是分配在“堆空间”中，而绝不会分配在“栈”上。 堆空间存放对象，栈帧存放指向对象的指针. 在类的头文件中尽量少引入其他头文件 多使用字面量语法，少用与之等量的方法 多用类型常量，少用#define预处理指令 12#define ANIMATIO">
<meta name="twitter:image" content="https://github.com/lizechuang/photoURL/blob/master/photo/%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png?raw=true">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lizechuang.github.io/2018/11/17/Effective Objective-C/"/>





  <title>Effective Objective-C | 李先生的随笔</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李先生的随笔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">如人饮水，冷暖自知</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lizechuang.github.io/2018/11/17/Effective Objective-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李先生的随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Effective Objective-C</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-17T21:00:00+08:00">
                2018-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/阅读/" itemprop="url" rel="index">
                    <span itemprop="name">阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Effective-Objective-C"><a href="#Effective-Objective-C" class="headerlink" title="Effective Objective-C"></a>Effective Objective-C</h1><p>使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；</p>
<p>使用函数调用的语言，则由编译器决定；</p>
<p>对象所占内存总是分配在“堆空间”中，而绝不会分配在“栈”上。</p>
<p>堆空间存放对象，栈帧存放指向对象的指针.</p>
<p>在类的头文件中尽量少引入其他头文件</p>
<p>多使用字面量语法，少用与之等量的方法</p>
<p>多用类型常量，少用#define预处理指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ANIMATION_DURATION 0.3 少用</span><br><span class="line">static const NSTimeInterval kAnimationDuration = 03 多用</span><br></pre></td></tr></table></figure>
<p>ps:若常量局限于某“编译单元”（也就是“实现文件”）之内，则在前面家字母k；若常量在类之外可见，则通常以类名为前缀</p>
<p>static const 来定义只在编译单元内可见的常量</p>
<p>extern const 来定义全局常量</p>
<p>用枚举表示状态、选项、状态码</p>
<a id="more"></a>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Objective-C的做法是，把实例变量当作一种存储偏移所用的“特殊变量”，交由“类对象”保管。</p>
<h3 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h3><p>1.原子性</p>
<h2 id="7-在对象内部尽量直接访问实例变量"><a href="#7-在对象内部尽量直接访问实例变量" class="headerlink" title="7.在对象内部尽量直接访问实例变量"></a>7.在对象内部尽量直接访问实例变量</h2><p>1.不经过OC的方法派发步骤，编译器所生成的代码会直接访问保存对象实例变量的那一块内存</p>
<p>2.直接访问实例变量时，不会调用其设置方法，这就饶过了为相关属性所定义的“内存管理语义”</p>
<p>3.直接访问实例变量时，不会触发“键值观测”</p>
<p>4.通过属性来访问有助于排查与之相关的错误，可以通过set，get方法</p>
<p>写入实例变量的时，通过设置方法来做，而在读取实例变量时，则直接访问。</p>
<h2 id="8-理解“对象等同性”这一概念"><a href="#8-理解“对象等同性”这一概念" class="headerlink" title="8.理解“对象等同性”这一概念"></a>8.理解“对象等同性”这一概念</h2><p>1.若想测试对象的等同性，请提供“isEqual：”与hash方法</p>
<p>2.相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象未必相同</p>
<p>3.不要盲目地逐个检测每条属性，而是应该按照具体需求来制定检测方案</p>
<p>4.编写hash方法时，应该使用计算速度快而且哈希码碰撞几率低的算法</p>
<h2 id="9-以“类族模式”隐藏实现细节"><a href="#9-以“类族模式”隐藏实现细节" class="headerlink" title="9.以“类族模式”隐藏实现细节"></a>9.以“类族模式”隐藏实现细节</h2><p>若想判断某对象是否为于类族中，不要直接检测两个“类对象”是否等同，应该用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[maybeAnArray isKindOfClass:[NSArray class]]</span><br></pre></td></tr></table></figure>
<p>1.类族模式可以把实现的细节隐藏在一套简单的公共接口后面</p>
<p>2.系统框架经常使用类族</p>
<p>3.从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。</p>
<h2 id="10-在既有类中使用关联对象存放自定义数据"><a href="#10-在既有类中使用关联对象存放自定义数据" class="headerlink" title="10.在既有类中使用关联对象存放自定义数据"></a>10.在既有类中使用关联对象存放自定义数据</h2><p>对象关联</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject (id object ,void *key ,id value ,objc_AssociationPolocy policy)</span><br><span class="line"></span><br><span class="line">id objc_getAssociatedObject (id object ,void *key)</span><br><span class="line"></span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure>
<p>1.可以通过“关联对象”机制来把两个对象连起来</p>
<p>2.定义关联对象时可指定内存管理语义，用以模拟定义属性时所采用的“拥有关系”与“非拥有关系”。</p>
<p>3.只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难以查询的bug。</p>
<h2 id="11-理解-objc-msgSend-的作用"><a href="#11-理解-objc-msgSend-的作用" class="headerlink" title="11.理解 objc_msgSend 的作用"></a>11.理解 objc_msgSend 的作用</h2><p>动态信息派发系统</p>
<h2 id="12-理解消息转发机制"><a href="#12-理解消息转发机制" class="headerlink" title="12.理解消息转发机制"></a>12.理解消息转发机制</h2><ol>
<li>若对象无法响应某个选择子，则进入消息转发流程</li>
<li>通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中</li>
<li>对象可以把其无法解读的某些选择子转交给其他对象来处理</li>
<li>经过上述两个之后，如果还是没办法处理选择子，那就启动完整的消息转发机制</li>
</ol>
<h2 id="13-用“方法调配技术”调试“黑盒方法”"><a href="#13-用“方法调配技术”调试“黑盒方法”" class="headerlink" title="13.用“方法调配技术”调试“黑盒方法”"></a>13.用“方法调配技术”调试“黑盒方法”</h2><p>method swizzing 方法调配 </p>
<p>交换方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void method_exchangeImplementations(Medthod m1, Medthod m2)</span><br><span class="line"></span><br><span class="line">Medthod class_getInstanceMethod(Class aClass, SEL aSelector)</span><br></pre></td></tr></table></figure>
<ol>
<li>在运行期，可以向类中新增或替换选择子所对应的方法实现</li>
<li>使用另一份实现来替换原有的方法实现，这道工序叫做“方法调配”，开发者常用此技术向原有实现中添加新功能</li>
<li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用</li>
</ol>
<h2 id="14-理解“类对象”的用意"><a href="#14-理解“类对象”的用意" class="headerlink" title="14.理解“类对象”的用意"></a>14.理解“类对象”的用意</h2><p>在运行期检视对象类型，这一操作叫“类型信息查询”</p>
<p>继承关系图</p>
<p><img src="https://github.com/lizechuang/photoURL/blob/master/photo/%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png?raw=true" alt="image"></p>
<h3 id="在类继承体系中查询类型信息"><a href="#在类继承体系中查询类型信息" class="headerlink" title="在类继承体系中查询类型信息"></a>在类继承体系中查询类型信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isMemberOfClass: 能够判断出对象是否为某个特定类的实例</span><br><span class="line"></span><br><span class="line">isKindOfClass: 能够判读出对象是否为某类或其派生类的实例</span><br></pre></td></tr></table></figure>
<ol>
<li>每一个实例都有一个指向Class对象的指针，用意表面其类型，而这些Class对象则构成的类的继承对象</li>
<li>如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知</li>
<li>尽量使用类型信息查询方法来确定对象类型，而不是直接比较类对象，因为某些对象可能实现了消息转发功能</li>
</ol>
<h2 id="15-用前缀避免命名空间冲突"><a href="#15-用前缀避免命名空间冲突" class="headerlink" title="15.用前缀避免命名空间冲突"></a>15.用前缀避免命名空间冲突</h2><h2 id="16-提供“全能初始化方法”"><a href="#16-提供“全能初始化方法”" class="headerlink" title="16.提供“全能初始化方法”"></a>16.提供“全能初始化方法”</h2><ol>
<li>在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法。</li>
<li>若全能初始化方法与超类不同，则需覆写超类中的对应方法。</li>
<li>如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常</li>
</ol>
<h2 id="17-实现description方法"><a href="#17-实现description方法" class="headerlink" title="17.实现description方法"></a>17.实现description方法</h2><ol>
<li>实现description方法返回一个有意义的字符串，用以描述该实例。</li>
<li>若想在调试时打印出更详尽的对象描述信息，则应该使用degdescription方法。</li>
</ol>
<h2 id="18-尽量使用不可变对象"><a href="#18-尽量使用不可变对象" class="headerlink" title="18.尽量使用不可变对象"></a>18.尽量使用不可变对象</h2><ol>
<li>尽量创建不可变的对象；</li>
<li>若某属性仅可用于对象内部修改，则在“Class-continuation分类”中将期由readonly属性拓展成readwrite属性；</li>
<li>不要把可变的collection作为属性公开，而应提供相关的方法，以此修改对象中的可变collection</li>
</ol>
<h2 id="19-使用清晰而协调的命名方式"><a href="#19-使用清晰而协调的命名方式" class="headerlink" title="19.使用清晰而协调的命名方式"></a>19.使用清晰而协调的命名方式</h2><ol>
<li>起名时应遵循标准的OC命名规范，容易理解</li>
<li>方法名要言简意赅</li>
<li>方法名里面不要使用缩略后的类型名称</li>
<li>给方法起名时的第一要务就是确其风格与你自己的代码或是所要集成的框架享符</li>
</ol>
<h2 id="20-为私有方法名加前缀"><a href="#20-为私有方法名加前缀" class="headerlink" title="20.为私有方法名加前缀"></a>20.为私有方法名加前缀</h2><ol>
<li>给私有方法的名称加上前缀，这样可以很容易地将其和公共方法区分开</li>
<li>不要单用一个下划线做私有方法的前缀，因为这种做法是预留给官方SDK</li>
</ol>
<h2 id="21-理解OC错误模型"><a href="#21-理解OC错误模型" class="headerlink" title="21.理解OC错误模型"></a>21.理解OC错误模型</h2><h3 id="NSError-封装了三条信息"><a href="#NSError-封装了三条信息" class="headerlink" title="NSError (封装了三条信息)"></a>NSError (封装了三条信息)</h3><ol>
<li>Error domain (错误范围，类型为字符串) 错误产生的范围</li>
<li>Error code (错误码，类型为整数) 独有的错误代码，用以指明在某个范围内具体发生了什么错误</li>
<li>User info (用户信息，类型为字典) 有关此错误的额外信息</li>
</ol>
<p>设计API时，NSError的第一种常见用法是通过委托协议来传递此错误。有错误发生时，当前对象会把错误信息经由协议中的某个方法传给其委托对象。</p>
<p>另外一种常见用法是：经由方法的“输出参数“返回给调用者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *error = nil;</span><br><span class="line">Bool Ret = [object doSomething:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">	//TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>只有发生了可能使整个应用程序奔溃的严重错误，才应使用异常。</li>
<li>在错误不那么严重的情况下，可以指派“委托方法”来处理错误，也可以把错误信息放在NSError对象里面，经由“输出对象”返回给调用者</li>
</ol>
<h2 id="22-理解NSCopying-协议"><a href="#22-理解NSCopying-协议" class="headerlink" title="22.理解NSCopying 协议"></a>22.理解NSCopying 协议</h2><p>使用对象时经常需要拷贝它。在OC中，此操作通过copy方法完成。如果想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法</p>
<blockquote>
<ul>
<li>(id)copyWithZone:(NSZone *)zone;</li>
</ul>
</blockquote>
<p>mutableCopy需要实现NSMutableCopying的协议</p>
<blockquote>
<ul>
<li>(id)mutableCopyWithZone:(NSZone *)zone;</li>
</ul>
</blockquote>
<p>有部分实例是有可变和不可变版本，为了实现可变和不可变的版本的自由切换，需要提供三个方法copy、immutableCopy、mutableCopy，其中，copy所返回的是与当前对象类型一致，其他两个方法则分别放回不可变和可变版本的拷贝</p>
<p>深拷贝和浅拷贝</p>
<ol>
<li>若想令自己所写的对象具有拷贝功能，则需要实现NSCopying协议。</li>
<li>如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying 和 NSMutableCopying协议</li>
<li>复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量使用浅拷贝</li>
<li>如果你所写的对象需要深拷贝，那么可以考虑新增一个专门执行深拷贝的方法</li>
</ol>
<h2 id="23-通过委托与数据源代理进行对象间通信"><a href="#23-通过委托与数据源代理进行对象间通信" class="headerlink" title="23.通过委托与数据源代理进行对象间通信"></a>23.通过委托与数据源代理进行对象间通信</h2><ol>
<li>委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象</li>
<li>将委托对象一个支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法</li>
<li>当某对象需要从另外一个对象获取数据时，可以使用委托模式。这种情况下，需要一个数据源协议（data source protocol）</li>
<li>若有必要，可实现含有位段的结构体，将委托对象是否能够响应相关协议方法这一消息缓存至其中</li>
</ol>
<h2 id="24-将类的实现代码分散到便于管理的数个分类之中"><a href="#24-将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="24.将类的实现代码分散到便于管理的数个分类之中"></a>24.将类的实现代码分散到便于管理的数个分类之中</h2><p>自我描述性代码</p>
<ol>
<li>使用分类机制把类的实现代码划分为易于管理的小块</li>
<li>将应该视为“私有”的方法归入名叫Private的分类中，以隐藏实现细节</li>
</ol>
<h2 id="25-总是为第三方类的分类添加前缀"><a href="#25-总是为第三方类的分类添加前缀" class="headerlink" title="25.总是为第三方类的分类添加前缀"></a>25.总是为第三方类的分类添加前缀</h2><ol>
<li>向第三方类中添加分类时，总应给其名称加上你专用的前缀</li>
<li>向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀、</li>
</ol>
<h2 id="26-勿在分类中声明属性"><a href="#26-勿在分类中声明属性" class="headerlink" title="26.勿在分类中声明属性"></a>26.勿在分类中声明属性</h2><h3 id="在分类中添加属性"><a href="#在分类中添加属性" class="headerlink" title="在分类中添加属性"></a>在分类中添加属性</h3><p>在分类中添加属性，需要为该属性实现存取方法。使用关联对象可以解决在分类中不能合成实例变量的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)array &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, kLee);</span><br><span class="line">&#125;</span><br><span class="line">- (void)setArray:(NSArray *)array &#123;</span><br><span class="line">    objc_setAssociatedObject(self, kLee, array, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>把封装数据所用的全部属性都定义在主接口里</li>
<li>在“class-continuation”之外的其他分类中，可以定义存取方式，但尽量不要定义属性</li>
</ol>
<h2 id="27-使用“class-continuation分类”隐藏实现细节"><a href="#27-使用“class-continuation分类”隐藏实现细节" class="headerlink" title="27.使用“class-continuation分类”隐藏实现细节"></a>27.使用“class-continuation分类”隐藏实现细节</h2><ol>
<li>通过“class-continuation分类” 向类中新增实例变量</li>
<li>如果某属性在主接口中声明为“ReadOnly”，而类的内部又要用设置方法修改这个属性，那么就要在“class-continuation 分类”拓展成“readWrite”</li>
<li>把私有方法的原型声明在“class-continuation 分类” 里面</li>
<li>若想使类所遵循的协议不为人所知，则可以在“class-continuation 分类”中声明</li>
</ol>
<h2 id="28-通过协议提供匿名对象"><a href="#28-通过协议提供匿名对象" class="headerlink" title="28.通过协议提供匿名对象"></a>28.通过协议提供匿名对象</h2><ol>
<li>协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵循某协议的id类型，协议里规定了对象所对应实现的方法。</li>
<li>使用匿名对象来隐藏类型名称。</li>
<li>如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以使用匿名对象来表示</li>
</ol>
<h2 id="29-理解引用计数"><a href="#29-理解引用计数" class="headerlink" title="29.理解引用计数"></a>29.理解引用计数</h2><ol>
<li>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当0，对象就销毁了</li>
<li>在对象生命期中，其余对象通过引用来保留或释放对象。保留与释放操作分别会递增及递减保留计数。</li>
</ol>
<h2 id="30-以ARC简化引用计数"><a href="#30-以ARC简化引用计数" class="headerlink" title="30.以ARC简化引用计数"></a>30.以ARC简化引用计数</h2><ol>
<li>有ARC之后，程序员就无须关心内存管理问题。</li>
<li>ARC管理对象生命周期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行”保留“及”释放”操作。</li>
<li>有方法所返回的对象，其内存管理语义总是通过方法名体现。ARC将此确定为开发者必须遵循的规则。</li>
<li>ARC只负责管理OC对象的内存。尤其要注意：CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。</li>
</ol>
<h2 id="31-在dealloc-方法中只释放引用并接触监听"><a href="#31-在dealloc-方法中只释放引用并接触监听" class="headerlink" title="31.在dealloc 方法中只释放引用并接触监听"></a>31.在dealloc 方法中只释放引用并接触监听</h2><ol>
<li>在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观测KVO”或者NSNotificationCenter等通知，不要做其他事情。</li>
<li>如果对象持有文件描述符等系统资源，那么一个专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close方法。</li>
<li>执行异步任务的方法不应在dealloc里调用，只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。</li>
</ol>
<h2 id="32-编写“异常安全代码”时留言内存管理问题"><a href="#32-编写“异常安全代码”时留言内存管理问题" class="headerlink" title="32.编写“异常安全代码”时留言内存管理问题"></a>32.编写“异常安全代码”时留言内存管理问题</h2><h2 id="33-以弱引用避免保留环"><a href="#33-以弱引用避免保留环" class="headerlink" title="33.以弱引用避免保留环"></a>33.以弱引用避免保留环</h2><ol>
<li>将某些引用设为weak，可以避免出现“保留环”。</li>
<li>weak引用可以自动清空，也可以不主动清空。自动清空（autonilling）时随着ARC而引入的新特性，由于运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。</li>
</ol>
<h2 id="34-以“自动释放池块”降低内存峰值"><a href="#34-以“自动释放池块”降低内存峰值" class="headerlink" title="34.以“自动释放池块”降低内存峰值"></a>34.以“自动释放池块”降低内存峰值</h2><ol>
<li>自动释放池排布在栈中，对象收到autorelease消息后，系统将其放在最顶端的池里。</li>
<li>合理运用自动释放池，可降低应用程序的存储峰值。</li>
<li>@autoreleasepool 这种新式写法能创建出更为轻便的内存释放池。</li>
</ol>
<h2 id="35-用“僵尸对象”调试内存管理问题"><a href="#35-用“僵尸对象”调试内存管理问题" class="headerlink" title="35.用“僵尸对象”调试内存管理问题"></a>35.用“僵尸对象”调试内存管理问题</h2><ol>
<li>系统在回收对象时，可以不将其真的回收，而是把它转化成僵尸对象。通过环境变量NSZombieEnabled可开启此功能。</li>
<li>系统会修改对象的isa对象指针，令其指向特殊的僵尸类，从而使该对象变成僵尸对象，僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。</li>
</ol>
<h2 id="36-不要使用retainCount"><a href="#36-不要使用retainCount" class="headerlink" title="36.不要使用retainCount"></a>36.不要使用retainCount</h2><ol>
<li>对象的保留计数看似游泳，实则不然，因为任何给定时间点上的“绝对保留计数”都无法反映对象生命周期的全貌。</li>
<li>引入ARC之后，retainCount 方法就正式废止了，在ARC下调用该方法会导致编译器报错。</li>
</ol>
<h2 id="37-理解“块”这一个概念"><a href="#37-理解“块”这一个概念" class="headerlink" title="37.理解“块”这一个概念"></a>37.理解“块”这一个概念</h2><ol>
<li>块是C、C++、Objective—c 中的语法闭包。</li>
<li>块可接受参数，也可返回值。</li>
<li>块可以分配在栈或者堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话就 和标准的OC对象一样，具有引用计数了。</li>
</ol>
<h2 id="38-为常用的块类型创建-typedef"><a href="#38-为常用的块类型创建-typedef" class="headerlink" title="38.为常用的块类型创建 typedef"></a>38.为常用的块类型创建 typedef</h2><ol>
<li>以typedef重新定义块类型，可令块变量用起来更加方便。</li>
<li>定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突。</li>
<li>不妨为同一块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需要修改typedef中的块签名即可，无须改动其他typedef。</li>
</ol>
<h2 id="39-用handler块降低代码分散程度"><a href="#39-用handler块降低代码分散程度" class="headerlink" title="39.用handler块降低代码分散程度"></a>39.用handler块降低代码分散程度</h2><ol>
<li>在创建对象时，可以通过内联的handler块将相关业务逻辑一并声明。</li>
<li>在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用handler块来实现，则可直接将块与相关对象放在一起。</li>
<li>设计API时如果用了handler块，那么可以添加一个参数，使调用者可以通过此参数来决定应该把块安排在哪个队列上执行。</li>
</ol>
<h2 id="40-用块引用其所属对象时不要出现保留环"><a href="#40-用块引用其所属对象时不要出现保留环" class="headerlink" title="40.用块引用其所属对象时不要出现保留环"></a>40.用块引用其所属对象时不要出现保留环</h2><ol>
<li>如果块所捕获的对象直接或者间接地保留了块本身，那么就得担心保留环问题。</li>
<li>一定要找个合适的时机解除保留环，而不能把责任推给API的调用者。</li>
</ol>
<p><strong>weak修饰的对象被Block引用,不会影响对象的释放,而</strong>strong在Block内部修饰的对象,会保证,在使用这个对象在scope内,这个对象都不会被释放,出了scope,引用计数就会-1,且<strong>strong主要是用在多线程运用中,若果只使用单线程,只需要使用</strong>weak即可</p>
<h2 id="41-多用派发队列，少用同步锁"><a href="#41-多用派发队列，少用同步锁" class="headerlink" title="41.多用派发队列，少用同步锁"></a>41.多用派发队列，少用同步锁</h2><ol>
<li>派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用@synchronized块或NSLock对象更简单。</li>
<li>将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步执行的线程。           </li>
<li>使用同步队列及栏栅块，可以令同步行为更加高效。                                                                                                                                                                                                                                                      </li>
</ol>
<h2 id="42-多用GCD-少用performSelector系列方法"><a href="#42-多用GCD-少用performSelector系列方法" class="headerlink" title="42.多用GCD,少用performSelector系列方法"></a>42.多用GCD,少用performSelector系列方法</h2><ol>
<li>performSelector 系列方法在内存管理方面容易有疏失。它无法确定要执行的选择子具体是什么。因而ARC编译器也就无法插入适当的内存管理方法。</li>
<li>performSelector系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都收到限制。</li>
<li>如果想把任务放在另一个线程上执行，那么最好不要用performSelector系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。</li>
</ol>
<h2 id="43-掌握GCD及操作队列的使用时机"><a href="#43-掌握GCD及操作队列的使用时机" class="headerlink" title="43.掌握GCD及操作队列的使用时机"></a>43.掌握GCD及操作队列的使用时机</h2><ol>
<li>在解决多线程与任务管理问题时，派发队列并非唯一方案。</li>
<li>操作队列提供了一套高级的OC API，能实现纯GCD 所具备的绝大多数功能。而且还能完成一些更为复杂的操作，那些操作若改用GCD来实现，则需另外编写代码。</li>
</ol>
<h2 id="44-通过Dispatch-Group-机制，根据系统资源状况来执行任务"><a href="#44-通过Dispatch-Group-机制，根据系统资源状况来执行任务" class="headerlink" title="44.通过Dispatch Group 机制，根据系统资源状况来执行任务"></a>44.通过Dispatch Group 机制，根据系统资源状况来执行任务</h2><ol>
<li>一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知。</li>
<li>通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源情况来调度这些并发执行的任务。</li>
</ol>
<h2 id="45-使用dispath-once-来执行只需运行一次的线程安全代码"><a href="#45-使用dispath-once-来执行只需运行一次的线程安全代码" class="headerlink" title="45.使用dispath_once 来执行只需运行一次的线程安全代码"></a>45.使用dispath_once 来执行只需运行一次的线程安全代码</h2><ol>
<li>经常需要编写“只需执行一次的线程安全代码”（thread-safe single-code execution）。通过GCD所提供的dispath_once函数，很容易就能实现此功能。</li>
<li>标记应该声明在static 或 global 作用域中，这样的话，在把只需执行一次的块传给dispath_once函数时，传进入的标记也是相同的。</li>
</ol>
<h2 id="46-不要使用dispath-get-current-queue"><a href="#46-不要使用dispath-get-current-queue" class="headerlink" title="46.不要使用dispath_get_current_queue"></a>46.不要使用dispath_get_current_queue</h2><ol>
<li>dispath_get_current_queue函数的行为常常与开发者所预期的不用，此函数已经废弃，只应做调试之用。</li>
<li>由于派发队列是按层级来组织的，所有无法但用某个队列对象来描述“当前队列”这一概念。</li>
<li>dispath_get_current_queue函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，常常也能用“队列特定数据”来解决。</li>
</ol>
<h2 id="47-熟悉系统框架"><a href="#47-熟悉系统框架" class="headerlink" title="47.熟悉系统框架"></a>47.熟悉系统框架</h2><p>iOS平台中的所有系统框架都是动态库（dynamic library）。第三方框架都是静态库（static library）</p>
<ol>
<li>许多系统框架都可以直接使用。其中最重要的是Foundation 与 CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。</li>
<li>很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理。</li>
<li>请记住：用纯C写成的框架与用OC写成的一样重要。</li>
</ol>
<h2 id="48-多用块枚举，少用for循环"><a href="#48-多用块枚举，少用for循环" class="headerlink" title="48.多用块枚举，少用for循环"></a>48.多用块枚举，少用for循环</h2><ol>
<li>遍历collection有四种方式。最简单的办法是for循环，其次是NSEnumerator遍历法及快速遍历法，最新、最先进的方式则是“块枚举法”。</li>
<li>“块枚举法”本身就能通过GCD来并发执行遍历操作，无须另外编写代码。而采用其他遍历方法则无法轻易实现这一点。</li>
<li>若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。</li>
</ol>
<h2 id="49-对自定义其内存管理语义的collection使用无缝桥接"><a href="#49-对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="49.对自定义其内存管理语义的collection使用无缝桥接"></a>49.对自定义其内存管理语义的collection使用无缝桥接</h2><ol>
<li>通过无缝桥接技术，可以在Foundation框架中的OC对象 与 coreFoundation 框架中的 C语言数据结构之间来回转换。</li>
<li>在CoreFoundation层面创建collection时，可以指定许多回调函数，这些函数表示此collection应如何处理其元素。然后，可以运用无缝桥接技术，将其转换成具备特殊内存管理语义的OC collection。</li>
</ol>
<h2 id="50-构建缓存时选用NSCache-而非-NSDictionary"><a href="#50-构建缓存时选用NSCache-而非-NSDictionary" class="headerlink" title="50.构建缓存时选用NSCache 而非 NSDictionary"></a>50.构建缓存时选用NSCache 而非 NSDictionary</h2><ol>
<li>实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache可以提供优雅的自动删减功能，而且是“线程安全的”，此外，它与字典不同，并不会拷贝键。</li>
<li>可以给NSCache对象设置上限，用以限制缓存中的对象总个数及“总成本”，而这些尺度则定义了缓存删减其中对象的时机，但是绝对不要把这些尺度当成可靠的“硬限制”，他们仅对NSCache起指导作用。</li>
<li>将NSPurgeableData 与NSCache搭配使用，可以实现自动清除数据的功能，也就是说，当NSPurgeableData对象所占用内存为系统所丢弃时，该对象自身也会从缓存中移除。</li>
<li>如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来很费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。</li>
</ol>
<h2 id="51-精简initialize-与load-的实现代码"><a href="#51-精简initialize-与load-的实现代码" class="headerlink" title="51.精简initialize 与load 的实现代码"></a>51.精简initialize 与load 的实现代码</h2><blockquote>
<p>+(void)load;</p>
</blockquote>
<ul>
<li>在加载阶段，如果类实现了load方法，那么系统就会调用它</li>
<li>对于加入运行期系统中的每一个类及分类来说，必定会调用此方法，而且只调用一次。（先调用类中的，再调用分类中的）。</li>
<li>在执行子类的load方法之前，必定会先执行所有超类的load方法，而如果代码还依赖了其他程序库，那么程序库里相关类的load方法也必定会先执行。</li>
<li>如果某个类本身没实现load方法，那么不管在各级超类里是否实现此方法，系统都不会调用。（不参与覆写机制）</li>
</ul>
<blockquote>
<p>+(void)initialize;</p>
</blockquote>
<ul>
<li>对于每个类来说，该方法会在程序首次用该类之前调用，且只调用一次；由于此方法遵从普通的覆写规则，所有通常应该在里面判断当前要初始化的时那个类。</li>
<li>它是有运行期系统来调用，决不应该通过代码直接调用。（惰性调用）</li>
</ul>
<ol>
<li>load与initialize方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入“依赖环”的几率。</li>
<li>无法在编译器设定的全局常量，可以放在initialize方法里初始化。</li>
</ol>
<h2 id="52-别忘了NSTimer会保留其目标对象"><a href="#52-别忘了NSTimer会保留其目标对象" class="headerlink" title="52.别忘了NSTimer会保留其目标对象"></a>52.别忘了NSTimer会保留其目标对象</h2><ol>
<li>NSTimer对象会保留其目标，直到计时器本身失效位置，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。</li>
<li>反复执行任务的计时器，很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那么肯定会导致保留环。这种环状保留关系，可能是直接发送的，也可能是通过对象图里的其他对象间接产生的。</li>
<li>可以扩产NSTimer的功能，用“块”来打破保留环。不过，除非NSTimer将来在公共接口提供此功能，否则必须创建分类，将相关实现代码加入其中。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS开发/" rel="tag"># iOS开发</a>
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/17/关于多个网络请求发送请求的设计/" rel="next" title="关于多个网络请求发送请求的设计">
                <i class="fa fa-chevron-left"></i> 关于多个网络请求发送请求的设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lee</p>
              <p class="site-description motion-element" itemprop="description">ios开发</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Effective-Objective-C"><span class="nav-number">1.</span> <span class="nav-text">Effective Objective-C</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#属性"><span class="nav-number">1.1.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性特质"><span class="nav-number">1.1.1.</span> <span class="nav-text">属性特质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-在对象内部尽量直接访问实例变量"><span class="nav-number">1.2.</span> <span class="nav-text">7.在对象内部尽量直接访问实例变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-理解“对象等同性”这一概念"><span class="nav-number">1.3.</span> <span class="nav-text">8.理解“对象等同性”这一概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-以“类族模式”隐藏实现细节"><span class="nav-number">1.4.</span> <span class="nav-text">9.以“类族模式”隐藏实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-在既有类中使用关联对象存放自定义数据"><span class="nav-number">1.5.</span> <span class="nav-text">10.在既有类中使用关联对象存放自定义数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-理解-objc-msgSend-的作用"><span class="nav-number">1.6.</span> <span class="nav-text">11.理解 objc_msgSend 的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-理解消息转发机制"><span class="nav-number">1.7.</span> <span class="nav-text">12.理解消息转发机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-用“方法调配技术”调试“黑盒方法”"><span class="nav-number">1.8.</span> <span class="nav-text">13.用“方法调配技术”调试“黑盒方法”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-理解“类对象”的用意"><span class="nav-number">1.9.</span> <span class="nav-text">14.理解“类对象”的用意</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在类继承体系中查询类型信息"><span class="nav-number">1.9.1.</span> <span class="nav-text">在类继承体系中查询类型信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-用前缀避免命名空间冲突"><span class="nav-number">1.10.</span> <span class="nav-text">15.用前缀避免命名空间冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-提供“全能初始化方法”"><span class="nav-number">1.11.</span> <span class="nav-text">16.提供“全能初始化方法”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-实现description方法"><span class="nav-number">1.12.</span> <span class="nav-text">17.实现description方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-尽量使用不可变对象"><span class="nav-number">1.13.</span> <span class="nav-text">18.尽量使用不可变对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-使用清晰而协调的命名方式"><span class="nav-number">1.14.</span> <span class="nav-text">19.使用清晰而协调的命名方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-为私有方法名加前缀"><span class="nav-number">1.15.</span> <span class="nav-text">20.为私有方法名加前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-理解OC错误模型"><span class="nav-number">1.16.</span> <span class="nav-text">21.理解OC错误模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSError-封装了三条信息"><span class="nav-number">1.16.1.</span> <span class="nav-text">NSError (封装了三条信息)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-理解NSCopying-协议"><span class="nav-number">1.17.</span> <span class="nav-text">22.理解NSCopying 协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-通过委托与数据源代理进行对象间通信"><span class="nav-number">1.18.</span> <span class="nav-text">23.通过委托与数据源代理进行对象间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-将类的实现代码分散到便于管理的数个分类之中"><span class="nav-number">1.19.</span> <span class="nav-text">24.将类的实现代码分散到便于管理的数个分类之中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-总是为第三方类的分类添加前缀"><span class="nav-number">1.20.</span> <span class="nav-text">25.总是为第三方类的分类添加前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-勿在分类中声明属性"><span class="nav-number">1.21.</span> <span class="nav-text">26.勿在分类中声明属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在分类中添加属性"><span class="nav-number">1.21.1.</span> <span class="nav-text">在分类中添加属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-使用“class-continuation分类”隐藏实现细节"><span class="nav-number">1.22.</span> <span class="nav-text">27.使用“class-continuation分类”隐藏实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-通过协议提供匿名对象"><span class="nav-number">1.23.</span> <span class="nav-text">28.通过协议提供匿名对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-理解引用计数"><span class="nav-number">1.24.</span> <span class="nav-text">29.理解引用计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-以ARC简化引用计数"><span class="nav-number">1.25.</span> <span class="nav-text">30.以ARC简化引用计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-在dealloc-方法中只释放引用并接触监听"><span class="nav-number">1.26.</span> <span class="nav-text">31.在dealloc 方法中只释放引用并接触监听</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-编写“异常安全代码”时留言内存管理问题"><span class="nav-number">1.27.</span> <span class="nav-text">32.编写“异常安全代码”时留言内存管理问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-以弱引用避免保留环"><span class="nav-number">1.28.</span> <span class="nav-text">33.以弱引用避免保留环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-以“自动释放池块”降低内存峰值"><span class="nav-number">1.29.</span> <span class="nav-text">34.以“自动释放池块”降低内存峰值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-用“僵尸对象”调试内存管理问题"><span class="nav-number">1.30.</span> <span class="nav-text">35.用“僵尸对象”调试内存管理问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-不要使用retainCount"><span class="nav-number">1.31.</span> <span class="nav-text">36.不要使用retainCount</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-理解“块”这一个概念"><span class="nav-number">1.32.</span> <span class="nav-text">37.理解“块”这一个概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-为常用的块类型创建-typedef"><span class="nav-number">1.33.</span> <span class="nav-text">38.为常用的块类型创建 typedef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-用handler块降低代码分散程度"><span class="nav-number">1.34.</span> <span class="nav-text">39.用handler块降低代码分散程度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-用块引用其所属对象时不要出现保留环"><span class="nav-number">1.35.</span> <span class="nav-text">40.用块引用其所属对象时不要出现保留环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-多用派发队列，少用同步锁"><span class="nav-number">1.36.</span> <span class="nav-text">41.多用派发队列，少用同步锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-多用GCD-少用performSelector系列方法"><span class="nav-number">1.37.</span> <span class="nav-text">42.多用GCD,少用performSelector系列方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-掌握GCD及操作队列的使用时机"><span class="nav-number">1.38.</span> <span class="nav-text">43.掌握GCD及操作队列的使用时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-通过Dispatch-Group-机制，根据系统资源状况来执行任务"><span class="nav-number">1.39.</span> <span class="nav-text">44.通过Dispatch Group 机制，根据系统资源状况来执行任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-使用dispath-once-来执行只需运行一次的线程安全代码"><span class="nav-number">1.40.</span> <span class="nav-text">45.使用dispath_once 来执行只需运行一次的线程安全代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-不要使用dispath-get-current-queue"><span class="nav-number">1.41.</span> <span class="nav-text">46.不要使用dispath_get_current_queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-熟悉系统框架"><span class="nav-number">1.42.</span> <span class="nav-text">47.熟悉系统框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-多用块枚举，少用for循环"><span class="nav-number">1.43.</span> <span class="nav-text">48.多用块枚举，少用for循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-对自定义其内存管理语义的collection使用无缝桥接"><span class="nav-number">1.44.</span> <span class="nav-text">49.对自定义其内存管理语义的collection使用无缝桥接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-构建缓存时选用NSCache-而非-NSDictionary"><span class="nav-number">1.45.</span> <span class="nav-text">50.构建缓存时选用NSCache 而非 NSDictionary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-精简initialize-与load-的实现代码"><span class="nav-number">1.46.</span> <span class="nav-text">51.精简initialize 与load 的实现代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-别忘了NSTimer会保留其目标对象"><span class="nav-number">1.47.</span> <span class="nav-text">52.别忘了NSTimer会保留其目标对象</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
